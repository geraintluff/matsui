<!DOCTYPE html>
<html>
	<head>
		<title>Matsui</title>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- includes main.js/main.css-->
		<link href="/style/blog/dist.css" rel="stylesheet">
		<script src="/style/blog/dist.js" defer class="style-main"></script>
		
		<script src="../matsui.js"></script>
		
		<style>
			.example, article.full .example {
				text-align: start;
				border: 1px solid #BBB;
				border-radius: 4px;
				background: #FFF;
				padding: 0;
				box-shadow: none;
				width: calc(max(300pt, 50%));
				max-width: 100%;
				margin: 0 auto 1.5rem auto;
				position: relative;
				z-index: 1;
				box-sizing: border-box;
			}
			/*
			@media (min-width: 600pt) {
				.example {
					float: right;
					clear: right;
					margin-left: 0.8em;
					margin-bottom: 1em;
				}
			}
			*/
			.example figure {
				text-align: start;
				padding: 0.5em 0.5em;
				margin: 0;
				width: 100%;
				max-width: 100%;
			}
			.example pre code {
				font-size: 0.8em;
			}
			.example-result, .example-js {
				background-color: #DDD5;
				padding: 0.5rem;
				border-top: 1px solid #BBB;
			}
			.example-js {
				background-color: #DEF8;
			}
			.example-result {
				border-bottom-left-radius: 4px;
				border-bottom-right-radius: 4px;
			}
			.example figure::before {
				content: "label";
				float: right;
				font-size: 0.65em;
				margin: 0;
				margin-top: -0.3rem;
				line-height: 1;
				padding: 0;
			}
			.example figure.example-html::before {
				content: "HTML";
				color: #600;
			}
			.example figure.example-js::before {
				content: "JS";
				color: #008;
			}
			.example figure.example-result::before {
				content: "result";
				color: #060;
			}
			.clear {
				clear: both;
			}
		</style>

		<template id="matsui-template">
			<figure class="example-html small"><pre class="language-html"><code>${data => (data.html || '').trim()}</code></pre></figure>
			<figure class="example-js small"><pre class="language-javascript"><code>${data => (data.js || '').trim().split('\n').map(x => "\t" + x).join("\n")}
			</code></pre><figcaption>{caption}</figcaption></figure>
			<figure class="example-result"></figure>
		</template>
		<script>
			let exampleTemplate = Matsui.global.fromElement('#matsui-template');
			function matsuiExample(obj) {
				let container = document.createElement('div');
				container.className = "example";
				document.currentScript.replaceWith(container);
				Matsui.addTo(container, obj, exampleTemplate);
				
				// Show result HTML
				let resultContainer = container.querySelector('.example-result');
				resultContainer.innerHTML = obj.html;
				// Execute JS
				let vars = Object.keys(obj.vars || {});
				let fn = Function.apply(null, vars.concat(obj.js + '\n' + (obj.extraJs || '')));
				let values = vars.map(name => {
					let value = obj.vars[name];
					if (typeof value === 'string') return resultContainer.querySelector(value);
					return value(resultContainer);
				});
				
				fn.apply(null, values)
			};
		</script>
	</head>
	<body>
		<script>
			if (0) {
				let nodeObserver = new MutationObserver(records => {
					records.forEach(record => {
						if (record.type == "characterData") {
							console.log("text:", record.target.nodeValue);
						} else if (record.type == "attribute") {
							console.log("attr:", record.attributeName, record.target.getAttribute(record.attributeName));
						} else {
							console.log("add", record.addedNodes, "remove", record.removedNodes);
						}
					});
				});
				nodeObserver.observe(document.body, {subtree: true, childList: true, characterData: true});
			}
		</script>
		<header class="blog"></header>
		<article class="main full">
			<header>
				<h1>Matsui</h1>
				<img src="Ricky_Matsui.png" style="float:right;height:4rem;width:4rem;margin:-4.5rem 0.25em 0 0;border-radius:5px">
				<p>Simple data-driven UIs</p>
			</header>
			
			<p>I wanted a framework/library for interactive UIs, but I'm uncomfortable with magic I don't understand, so I made something simple enough for me to explain how it's implemented.</p>

			<script>
				matsuiExample({
					html: `<script src="matsui.js"></${'script'}>

<div>
	<div>Counter: {counter}</div>
	<div>Doubled: \${data => data.counter*2}</div>
	<button $click="\${data => data.counter++}">
		add
	</button>
</div>`,
					js: `Matsui.replace(div, {counter: 0});`,
					vars: {
						div: 'div'
					}
				});
			</script>
			
			<nav class="auto"></nav>

			<h2>Overview</h2>

			<h3>Principles</h3>
			<ul>
				<li>concise implementation
				<li>only updates the page where needed
				<li>plain JavaScript library (no compilation step)
				<li>CSP (Content Security Policy) support
			</ul>
			
			<h3>Data & Templates</h3>
			<p>The data is JSON-like, except <code>null</code> is equivalent to a value/property not existing.  You interact with it by directly changing values (rather than calling methods).</p>
			<p>Templates are functions which produce a node and a list of update functions, each making DOM changes based on their single <code>data</code> argument.  You can write templates in a <code>{...}</code>-based syntax, or directly in JavaScript.</p>
			
			<h3>Partial Updates</h3>
			<p>Matsui uses various <code>Proxy</code>s to:</p>
			<ul>
				<li>generate a merge object for all changes made to the data</li>
				<li>associate a "hidden merge" with data objects (which recurses appropriately through property access)</li>
				<li>track how a data object is accessed</li>
			</ul>
			<p>When update functions are called, it keeps track of what parts of the data they use.  When the data is changed, a merge object is attached to the data, and it only calls update functions affected by the merge.</p>
			
			<h2>HTML Template Syntax</h2>
			<p>Templates use <code>{...}</code> (property name) and <code>${...}</code> (expressions) inside strings.  The JavaScript expressions in <code>${...}</code> must evaluate to a function, taking data as their first argument.</p>

			<script>
				matsuiExample({
					html: `
<template id="greet">
	<p>Hello {name}!</p>
	<p>1 + 1 = \${data => 1 + 1}</p>
</template>

<div></div>`,
					js: `
let template = Matsui.global.fromElement(greet);
let data = {name: "you"};
let render = Matsui.addTo(div, data, template);
`,
					vars: {
						div: 'div',
						greet: '#greet'
					}
				});
			</script>

			<h3>In-place templates</h3>
			<p>When you make a template from an existing element, it returns the original node(s) the first time you use that template (and copies from then on).</p>
			<p>This probably doesn't make a difference for <code>&lt;template></code>s, but it means if you fill an element out <em>using itself as a template</em>, you end up modifying the existing page's DOM nodes in-place.</p>

			<script>
				matsuiExample({
					html: `
<div>Hello, {name}!</div>
`,
					js: `
let render = Matsui.replace(div, {name: "you"});
`,
					vars: {
						div: 'div'
					}
				});
			</script>

			<h3>Named templates</h3>
			<p>These values can be prefixed with a template identifier (e.g. <code>$list</code>) which specifies which template should be used to render that value:</p>
			<script>
				matsuiExample({
					html: `
<template name="named-item">
	<li>{=}</li>
</template>

<template id="named-list">
	<ol>
		$list$named-item{list}
	</ol>
</template>

<div>$named-list{=}</div>`,
					js: `
Matsui.global.addAll(); // scans the whole page
let data = {
	list: ["one", "two", "three"]
};
let render = Matsui.replace(div, data);
`,
					vars: {
						div: 'div'
					}
				});
			</script>
			<p>You can add named elements from <code>&lt;template></code>s with a <code>name</code> or <code>id</code> attribute, by using <code>.addAll(queryOrList)</code>.</p>
			<p>You can add a named template from <em>any</em> element using <code>.addElement(name, ...)</code>.</p>

			<h3>CSP support &amp; tagged templates</h3>
			<p><a href="https://content-security-policy.com/">Content Security Policies</a> place extra restrictions on what gets run/displayed in a web-page.  This includes banning <code>eval</code>/<code>Function()</code>, inline event handlers (<code>onclick="myFunc()"</code>) and inline <code>&lt;script></code> elements.</p>
			<p>When this is active, we can't define templates using DOM nodes, but we can use the same syntax as a tagged template:</p>
			<script>
				matsuiExample({
					html: `
<div></div>`,
					js: `
let template = Matsui.global.fromTag\`
	<p>Hello {name}! 1+1=\${data => 1 + 1}</p>
\`;
let data = {name: "you"};
let render = Matsui.addTo(div, data, template);
`,
					vars: {
						div: 'div'
					}
				});
			</script>
			<p>To add these as named templates, you can use <code>.addTag(name)</code>:</p>
			<script>
				matsuiExample({
					html: `
<div>$named-tag{=}</div>`,
					js: `
Matsui.global.addTag('named-tag')\`
	<p>Hello {name}! 1+1=\${data => 1 + 1}</p>
\`;
let data = {name: "you"};
let render = Matsui.replace(div, data);
`,
					vars: {
						div: 'div'
					}
				});
			</script>
			
			<h3>Attributes</h3>
			<p>Attributes which start with <code>$</code> are treated as templated attributes.  The default implementation does one of the following:</p>
			<ol>
				<li>if an <code>on...="..."</code> property exists on the object, add an event handler which calls the associated function (with an additional event argument)</li>
				<li>if a property is already defined on the element with that name (e.g. <code>value</code> for <code>&lt;input></code>s), update that property.</li>
				<li>otherwise, set/update the corresponding attribute value</p>
			</ol>
			
			<script>
				matsuiExample({
					html: `
<div>
	<button $click="\${data => data.counter++}">
		increment
	</button>
	<input type="submit" $value="{counter}">
	<img src="//missing" $alt="Alt: {counter}">
</div>
`,
					js: `
let render = Matsui.replace(div, {counter: 0});
`,
					vars: {
						div: 'div',
					}
				});
			</script>
			<p>However, you can also provide a handler for a particular <code>$...</code> attribute name, for more complex behaviour.  Here, a single attribute:</p>
			<ul>
				<li>listens for mouse-clicks</li>
				<li>listens for the <kbd>Enter</kbd> key</li>
				<li>styles the cursor</li>
				<li>makes the element tab-focusable</li>
			</ul>
			<script>
				matsuiExample({
					html: `
<div>
	<div $press="\${data => data.counter++}">
		counter: {counter}<br>
		updates: <span class="updates"></span>
	</div>
</div>
`,
					js: `
let templateSet = Matsui.global;
templateSet.attributes.press = (node, attrFn) => {
	// add click and keyboard handlers
	addEventHandlers(node, attrFn);
	
	// this lives as long as the template binding
	let updateCount = 0;

	// optional update function return
	return data => {
		// Access the data, so we get called again
		Matsui.access.pierce(data);
		node.querySelector(".updates")
			.textContent = ++updateCount;
	};
};
let render = Matsui.replace(div, {counter: 0});
`,
					extraJs: `
function addEventHandlers(node, getValue) {
	// mouse interaction
	node.addEventListener('click', e => {
		getValue(e);
	});
	node.style.cursor = "pointer";
	node.style.userSelect = "none";
	
	// Keyboard interaction
	node.setAttribute("tabindex", 0);
	node.addEventListener('keydown', e => {
		if (e.key === 'Enter') {
			e.preventDefault();
			e.stopPropagation();
			getValue(e);
		}
	});
};
`,
					vars: {
						div: 'div',
					}
				});
			</script>
			<p>The second <code>attrFn</code> argument to our attribute handler evaluates the attribute expression.  Any extra arguments you pass in are included as extra arguments to the <code>${data => ...}</code> functions in the attribute's value.</p>

			<h3>Directives</h3>
			<p>When a template contains another <code>&lt;template></code>, that inner template can be modified by "directives", which are functions which map one template to another.  They are specified on <code>templateSet.directives[...]</code>, and referenced with <code>@...</code> attributes on <code>&lt;template></code>.</p>
			<p>A built-in example is <code>@foreach</code>, which wraps a template inside a list.  This is particularly useful in places where text nodes aren't allowed (such as inside <code>&lt;table></code>), but you can define whatever directives you like:</p>
			
			<script>
				matsuiExample({
					html: `
<div>
	<ol>
		<template @foreach="{items}">
			<li>{=}</li>
		</template>
	</ol>
	<template @repeat="3">
		{greeting}<br>
	</template>
</div>
`,
					js: `
function repeat(tmpl, attrVal, templateSet) {
	return innerTmpl => {
		let n = document.createDocumentFragment();
		let fns = [];
		// doesn't need data
		let repeats = parseInt(attrVal()) || 0;
		
		for (let r = 0; r < repeats; ++r) {
			let binding = tmpl(innerTmpl);
			n.append(binding.node);
			fns = fns.concat(binding.updates);
		}
		return {node: n, updates: fns};
	};
}
Matsui.global.directives.repeat = repeat;
					
let render = Matsui.replace(div, {
	greeting: "Hello!",
	items: ["one", "two", "three"]
});
`,
					vars: {
						div: 'div',
					}
				});
			</script>

			<h3>The "dynamic" template</h3>
			<p>Every template set (which is what <code>Matsui.global</code> is) has a <code>.dynamic</code> property.  This is a wrapper template which chooses which template to <em>actually</em> use based on template filters, with newer ones having priority.</p>
			<p>Every method that adds a named template has an optional <code>filter</code> argument, which maps <code>data</code> to a boolean saying whether the template can render that data.</p>
			<script>
				matsuiExample({
					html: `
<div>
	<button $click="\${d => extendSequence(d)}">
		add
	</button>
	<button $click="\${d => d.sequence = []}">
		clear
	</button>
	<br>
	$list$fizzbuzz{sequence}
</div>`,
					js: `
window.extendSequence = data => {
	let n = data.sequence.length + 1;
	data.sequence.push(n);
}

// new set, falling back to global if needed
let fizzbuzz = Matsui.global.extend();

// add templates with filters (but no name)
fizzbuzz.addTag(null, d => true)
	\`$json{=}<br>\`;
fizzbuzz.addTag(null, d => !(d%3))
	\`fizz<br>\`;
fizzbuzz.addTag(null, d => !(d%5))
	\`buzz<br>\`;
fizzbuzz.addTag(null, d => !(d%15))
	\`fizzbuzz<br>\`;

let templates = Matsui.global.extend();
// $fizzbuzz will use \`fizzbuzz.dynamic\`
templates.add("fizzbuzz", fizzbuzz);

// Third argument can be a template set
Matsui.replace(div, {sequence: []}, templates);
`,
					vars: {
						div: 'div'
					}
				});
			</script>
			<p>However, it's worth noting that this <strong>template selection is sticky</strong>.  This means that if the previously-used template's filter still returns <code>true</code>, it will continue to be used - even if there are higher-priority templates which would also accept the data.</p>
		</article>
	</body>
</html>

<!DOCTYPE html>
<html>
	<head>
		<title>Matsui</title>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- includes main.js/main.css-->
		<link href="/style/blog/dist.css" rel="stylesheet">
		<script src="/style/blog/dist.js" defer class="style-main"></script>
		
		<script src="../matsui.js"></script>
		
		<style>
			.example {
				text-align: start;
				border: 1px solid #BBB;
				border-radius: 4px;
				background: #FFF;
				padding: 0;
				box-shadow: none;
				max-width: 300pt;
				margin: auto;
				position: relative;
				z-index: 1;
				box-sizing: border-box;
			}
			@media (min-width: 600pt) {
				.example {
					float: right;
					clear: right;
					margin-left: 0.8em;
				}
			}
			.example .example-input {
				padding: 0 0.5em;
			}
			.example pre code {
				font-size: 0.8em;
			}
			.example-result {
				text-align: start;
				background-color: #DDD8;
				margin: 0;
				padding: 0.5rem;
				border-top: 1px solid #BBB;
				border-bottom-left-radius: 4px;
				border-bottom-right-radius: 4px;
			}
		</style>

		<template id="matsui-template">
			<div class="example">
				<figure class="example-input small"><pre class="language-html"><code>{{=> (data.html || '').trim() }}

&lt;script>
<script @expr>
(data.js || '').split('\n').map(x => "\t" + x).join("\n")
</script>
&lt;script></code></pre></figure>
				<figure class="example-result"></figure>
			</div>
		</template>
		<script>
			function matsuiExample(obj) {
				let template = Matsui.template.fromElement(document.querySelector('#matsui-template'));
				Matsui.replace(document.currentScript, obj, template);
			};
		</script>
	</head>
	<body>
		<header class="blog"></header>
		<article class="main full">
			<header>
				<h1>Matsui <img src="Ricky_Matsui.png" style="float:right;height:1.5em;width:1.5em;margin:-0.25em -0.25em -0.25em -1.25em;border-radius:5px"></h1>
				<p>Simple data-driven UIs</p>
			</header>
			
			<p>There are already loads of JavaScript frameworks/libraries for interactive UIs or putting data on the screen - but the magic inside them feels unnervingly complex, so I made something simple enough for me to explain how it's implemented.</p>

			<script>
				matsuiExample({
					html: `<script src="matsui.js"></${'script'}>

<div>
	<div>Counter: {{counter}}</div>
	<div>Next: {{=> data.counter + 1}}</div>
	<button @click="++data.counter">add</button>
</div>`,
					js: `Matsui.inPlace(div, {counter: 0});`
				});
			</script>

			<h2>Goals</h2>
			<ul>
				<li>small &amp; simple implementation
				<li>only updates the page where needed
				<li>plain JavaScript library (no compilation step)
			</ul>
			
			<h3>Data structure</h3>
			<p>Data is "JSON-like", which means it's cycle-free, and you interact with it by changing values (rather than calling methods).</p>
			<p><code>null</code> is equivalent to a value not existing, which means that all changes can be represented as JSON Patch Merge objects.  This is a simple structure which makes it easy to see which parts of the data have changed.</p>
			<todo>diagram</todo>
			
			<h2>Stuff you provide</h2>
			
			<h3>Templates</h3>
			<p>Templates are functions which product <dfn>binding info</dfn>, which is:</p>
			<ul>
				<li>a node (probably a <code>DocumentFragment</code>) ready to be added to the DOM
				<li>a list of update functions, which update the node/tree when given a data value.
			</ul>
			<p>There are helper methods to construct templates based on <code>&lt;template></code>s, but you can generate your own templates instead (e.g. if you don't like the default templating syntax ðŸ˜‰).
			</script>

			<h2>What the library gives you</h2>
			<todo>add <code>.data()</code> for direct data manipulation?</todo>
			<p>The main API methods (<code>Matsui.show()</code> and <code>Matsui.replace()</code>) render the data to the page using templates, provide <code>.merge()</code>/<code>.replace()</code> methods for you to change the data, and <code>.track()</code> so you can listen for changes made through the UI.  These are implemented using a few ingredients:</p>

			<h3>Partial updates</h3>
			<p>The main thing the library does it to take a list of update functions (provided by a template), and when the data changes, only call <em>some</em> of the update functions as needed.  This needs a few things to work:</p>
			<h4>Access tracking</h4>
			<p>It wraps the data in a <code>Proxy</code> object, which tracks which parts of data are accessed when calling each update function.  When a change happens, it looks at the corresponding merge object to decide which updates to call.</p>
			<h4>Hidden merge objects</h4>
			<p>To keep template code simple, the update functions always take a <code>data</code> argument.  However (using a <code>WeakMap</code> and another <code>Proxy</code> wrapper) we associate a merge object with each data object.</p>
			<p>This means that when an update function hand over to another rendering method (passing in the same data, sub-data, or some new generated value), the library can check whether that actually needs to be called.</p>
			<todo>Maybe expose <code>.changed()</code> on Matsui, in case you want to implement this yourself.</todo>
			
			<h3>Change-tracking objects</h3>
			<p>This wraps data in another <code>Proxy</code> which catches modifications to the data, and generates merge objects for those changes.  These changes are passed to an update function (individually and synchronously, or collating multiple changes and calling later).</p>
			<p>This is used to update the UI when the data is changed, either through user interaction (as defined by a template) or from an external source.</p>
			
			<h3>Default rendering tools</h3>
			<p>The library also provides some other useful things:</p>
			<h4>Single-value binding</h4>
			<p>This uses a marker node (usually an empty text node), and switches between rendering plain values (strings/numbers/etc.) as text, or objects/arrays using a template, placing its content directly before the marker node.</p>
			<h4>Multi-value binding</h4>
			<p>Using a similar end-marker node, this renders a list of single-value bindings, with values mapped from the (index, value) or (key, value) pairs of array/object values.</p>

			<h4>Template tools</h4>
			<p>There are helper methods for creating various types of template, like:</p>
			<ul>
				<li>from <code>&lt;template></code>s, other elements, or raw HTML</li>
				<li>from a list of templates (each with a <code>.filter()</code> method), using the first one which says it can render the given data.</li>
			</ul>
		</article>
	</body>
</html>

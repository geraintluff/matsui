<!DOCTYPE html>
<html>
	<head>
		<title>Matsui</title>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- includes main.js/main.css-->
		<link href="/style/blog/dist.css" rel="stylesheet">
		<script src="/style/blog/dist.js" defer class="style-main"></script>
		
		<script src="./matsui.js"></script>
	</head>
	<body>
		<header class="blog"></header>
		<article class="main">
			<header>
				<h1>Matsui <img src="Ricky_Matsui.png" style="float:right;height:1.5em;width:1.5em;margin:-0.25em -0.25em -0.25em -1.25em;border-radius:5px"></h1>
				<p>Simple data-driven UIs</p>
			</header>
						
			<script type="markdown">
				There are already loads of JavaScript frameworks/libraries for interactive UIs or putting data on the screen, but it's not obvious how they work under the hood.
				
				I don't like using magic I can't see, so I made something simple which I can actually explain.

				## Goals
				
				* small
				* simple to understand
				* only updates the page where needed
				* plain JavaScript library (no compilation step)
				
				### Data structure
				
				Data is JSON-like, and `null` is equivalent to a value not existing.  This means that changes can be represented as JSON Patch Merge objects - a simple structure which makes it easy to see which parts of the data have changed.
				
				## Stuff you provide
				
				### Templates
				
				Templates produce **binding info**, which consists of:
				
				* a node (probably a <code>DocumentFragment</code>) ready to be added to the DOM
				* a list of update functions, which update the node/tree when given a data value.
				
				There are helper methods to construct templates based on `<template>` elements, but you could generate your own templates instead (e.g. if you don't like the default templating syntax ðŸ˜‰).
				
				### Template selectors
				
			</script>
			
			<hr>
			
			<h2>Stuff you provide</h2>

			<h3>Templates</h3>
			<p>A template does two things:</p>
			<ul>
				<li>filtering (to check whether this template can display the given data)</li>
				<li>generate binding info, specifically:
					<ul>
						<li>a node (probably a <code>DocumentFragment</code>) which you can add to the DOM</li>
						<li>a list of update operations, each of which (synchronously) updates that node tree in some way.</li>
					</ul>
				</li>
			</ul>
			<p>These update operations are all executed, to fill out the node tree.  For later updates, the library tracks which bits of the input data each one uses, so only some (or none) of them need to be run.</p>
			<h4>HTML Templates</h4>
			<p>Templates can be constructed by scanning <code>&lt;template></code> elements, using <code>{{...}}</code> placeholders.  Rather than parsing these template expressions each time, they're parsed once, and the paths through the node tree are stored, and when the tree is cloned (for use in the actual UI) these paths are used to hook update functions up with the equivalent nodes from the cloned tree.</p>
			<p>You can also scan an element for <code>&lt;template></code> nodes, or declare <code>&lt;template></code>s inside a <code>&lt;template></code>, which would only be used for that template's immediate children.</p>
			
			<h3>Template Selector</h3>
			<p>A template selector has a `.chooseTemplate(data)` method, which returns a template.</p>
			<p>It has an optional `.innerTemplates` property, to specify a different selector to use when rendering content <em>inside</em> the selected template's presentation.</p>
			<aside>TODO: should this be returned as part of the choosing?  Would we ever want to make the inner templates data-dependent?</aside>
			<h4>HTML Templates</h4>
			<p>There's a helper class which collects <code>&lt;template></code>s from the page (or an element), and makes a selector from them.</p>
		
			<h2>Library components</h2>
			
			<h3>Template binding</h3>
			<p>This takes the update functions generated by a template, and provides a single update method.</p>
			<p>This update method will call some, none or all of the update functions, depending on what's changed in the data.  This is done by:</p>
			<ul>
				<li>wrapping a <code>Proxy</code> around the data, which keeps track of which pieces of data are accessed during each update.</li>
				<li>secretly link the merge object representing the data change to the data (also using a <code>Proxy</code>.</li>
			</ul>
			<p>This means a template's update functions don't need to keep track of the state, and can access/wrap/manipulate it as normal.  The template binding will fetch the corresponding part of the merge object, and only call update methods which accessed relevant data on the previous update call.</p>
			<aside>TODO: some diagrams or code examples might help here</aside>

			<h3>Value binding</h3>
			<p>This takes a single "end marker" node, and a template selector.  It provides:</p>
			<ul>
				<li>an update method displays the data directly before end marker</li>
				<li>a <code>.remove()</code> method, which takes out everything <em>including</em> the end marker.</li>
			</ul>
			<p>Basic values (e.g. strings, numbers) will be shown using just a text node.  Objects (including arrays) will be bound using a template and a template binding.</p>
			<aside>TODO: currently called <code>ReplacingBind</code></aside>
			<h4>Multi-value binding</h4>
			<p>There's a multi-value binding which manages a list of value bindings, corresponding to the entries of an array or the key/value pairs of an object.  These are all placed next to each other directly before the end marker.</p>
			<p>If the items in your array (or object) are basic values, then no template will be used.  Therefore, if you want to output a list with more formatting, you can give the multi-value bindin a mapping function which turns these into objects (which will then be shown using a template).</p>

			<h3>Merge notification object</h3>
			<p>This wraps data in a <code>Proxy</code>, so that when the tree is changed by assignment, it can generate a merge object representing the change.  These changes can be collected and used to update the display.</p>

			<h3>Mergeable display</h3>
			<p>This displays data on the page, watching for changes from the interface (which is reported as merge objects) and providing <code>.merge()</code> and <code>.replace()</code> methods for making your own data updates.</p>
		</article>
	</body>
</html>

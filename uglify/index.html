<!DOCTYPE html>
<html>
	<head>
		<title>Uglify</title>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>
			body {
				margin: 0;
				padding: 0;
				display: flex;
				height: 100vh;
				width: 100vw;
				flex-direction: row;
				font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
				font-size: 12pt;
				font-size: calc(max(8pt, min(12pt, 3vw)));
				tab-size: 4;
			}
			body {
				flex-wrap: wrap;
			}
			#input, #results {
				flex-grow: 1;
				flex-basis: 300pt;
			}
			#results {
				display: flex;
				flex-direction: column;
			}
			#controls {
				display: flex;
				flex-direction: row;
				flex-wrap: wrap;
				flex-grow: 0;
			}
			#controls > * {
				flex-grow: 1;
				width: 5em;
				line-height: 2;
				text-align: center;
			}
			button {
				background: #333;
				color: #FFF;
				border: 2px solid #000;
				font: inherit;
				padding: 0;
				flex-grow: 1;
				cursor: pointer;
			}
			#options-button {
				background: #FFF;
				color: #000;
				border-color: #DDD;
			}
			#result-size {
				padding: 0em 0.5em;
				white-space: nowrap;
			}
			#output {
				flex-grow: 1;
				background: #EEE;
			}
			textarea {
				font-size: 0.85em;
				font-family: "Lucida Console", "Lucida Sans Typewriter", monaco, "Bitstream Vera Sans Mono", monospace;
				padding: 0.5em;
			}
			
			.interaction-drop {
				outline: 0.5em dotted currentcolor;
				outline-offset: -0.65em;
				opacity: 0.65;
			}
			
			dialog::backdrop {
				background-color: #8889;
				backdrop-filter: blur(1px) grayscale(50%);
				cursor: pointer; /* click to exit */
			}
			
			dialog {
				border-radius: 5px;
			}

		</style>
	</head>
	<body>
		<textarea id="input" placeholder="JS code" autofocus
			$input-keypath="input.code"
			$input-done="${run}"
			$drop-file="${(d, files) => {
				Promise.all(files.map(f =>
					f.text().then(text => ({
						name: f.name,
						text: text
					}))
				)).then(list => {
					d.input.code = list.map(entry => `//---- ${entry.name} ----\n\n${entry.text}`).join('\n\n');
				});
			}}" data-accept="text/*"></textarea>
		
		<div id="results">
			<div id="controls">
				<button id="go-button" $click="${run}">minify</button>
				<button id="options-button" $click="${d => d.optionsDialog = true}">options</button>
				<div id="result-size">${d => d.input.code.length} â†’ ${d => (d.output.error ? 'Error' : d.output.code.length + ' bytes')}</div>
				<label>
					<input type="checkbox" $input-keypath="live">
					live
				</label>
			</div>
			<textarea id="output" placeholder="minified" readonly
				$value="${d => d.output.error || d.output.code}"></textarea>
		</div>
		
		<template @if="{optionsDialog}">
			<dialog $modal="1" $modal-close="${d => d.optionsDialog = false}">
				<div>Hello!
				</div>
			</dialog>
		</template>

		<!-- npx uglify-js --self --compress --mangle --output uglify.min.js -->
		<script src="uglify.min.js"></script>
		<script src="../matsui.js"></script>
		<script src="../extra/sync.js"></script>
		<script src="../extra/log-dom.js"></script>
		<script src="../extra/interaction.js"></script>
		<script>
			function run(data) {
				let $ = document.querySelector.bind(document);

				let options = JSON.parse(JSON.stringify(data.options));
				if (options.mangle && options.mangle.properties && options.mangle.properties.regex) {
					options.mangle.properties.regex = new RegExp(options.mangle.properties.regex);
				}
				let outputObj = UglifyJS.minify(data.input.code, options);
				data.output = outputObj;
			}
		
			function defaultOptions() {
				return {
					compress: {
						passes: 2
					},
					mangle: {
						properties: {
							regex: "^(m_|#)"
						}
					},
					output: {
						ascii_only: true
					}
				};
			}
			let optionsSchema = {
				title: "UglifyJS options",
				$schema: true, // not kosher, but we just test for truthiness anyway
			};
			let wrapped = Matsui.replace(document.body, {
				input: {code: 'console.log("Hello, world!");'},
				live: false,
				output: {code: ''},
				options: defaultOptions()
			});
			wrapped.addUpdates(data => {
				if (data.live) run(data);
			});
			
			wrapped.syncHash(data => ({
				get path() {
					return data.live ? 'live' : '';
				},
				set path(path) {
					data.live = (path == 'live');
				},
				get query() {
					return Matsui.merge.make(defaultOptions(), data.options)
				},
				set query(query) {
					data.options = Matsui.merge.apply(defaultOptions(), query);
				}
			}));
			wrapped.syncLocalStorage(data => ({
				get uglifyInput() {
					return data.input;
				},
				set uglifyInput(input) {
					if (input) data.input = input;
				}
			}));
		</script>
	</body>
</html>
